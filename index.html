<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>snarky-smt</title><meta name="description" content="Documentation for snarky-smt"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">snarky-smt</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>snarky-smt </h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#snarky-smt" id="snarky-smt" style="color: inherit; text-decoration: none;">
  <h1>snarky-smt</h1>
</a>
<p>Sparse Merkle Tree for SnarkyJs (existence / non-existence merkle proof). Note that currently only the methods(methods whose method name ends with InCircuit) of verifying the merkle tree proof and calculating the new state root can be executed in zkapp(the smart contract of the mina protocol), other methods need to be executed outside zkapp.</p>

<a href="#install" id="install" style="color: inherit; text-decoration: none;">
  <h1>Install</h1>
</a>
<pre><code class="language-bash"><span class="hl-0">npm install --save snarky-smt</span><br/><span class="hl-1"># or with yarn:</span><br/><span class="hl-0">yarn add snarky-smt</span>
</code></pre>

<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
  <h1>Usage</h1>
</a>
<pre><code class="language-typescript"><span class="hl-2">import</span><span class="hl-0"> { </span><span class="hl-3">Level</span><span class="hl-0"> } </span><span class="hl-2">from</span><span class="hl-0"> </span><span class="hl-4">&#39;level&#39;</span><span class="hl-0">;</span><br/><span class="hl-2">import</span><span class="hl-0"> { </span><span class="hl-3">Field</span><span class="hl-0">, </span><span class="hl-3">Poseidon</span><span class="hl-0"> } </span><span class="hl-2">from</span><span class="hl-0"> </span><span class="hl-4">&#39;snarkyjs&#39;</span><span class="hl-0">;</span><br/><span class="hl-2">import</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-3">verifyCompactProof</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">verifyProof</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">SparseMerkleTree</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">LevelStore</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">MemoryStore</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">computeRootByFieldInCircuit</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">computeRootInCircuit</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">verifyProofByFieldInCircuit</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">verifyProofInCircuit</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-3">SMT_EMPTY_VALUE</span><span class="hl-0">,</span><br/><span class="hl-0">} </span><span class="hl-2">from</span><span class="hl-0"> </span><span class="hl-4">&#39;snarky-smt&#39;</span><span class="hl-0">;</span><br/><br/><span class="hl-1">// create a memory store</span><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">store</span><span class="hl-0"> = </span><span class="hl-5">new</span><span class="hl-0"> </span><span class="hl-6">MemoryStore</span><span class="hl-0">&lt;</span><span class="hl-7">Field</span><span class="hl-0">&gt;();</span><br/><span class="hl-1">// or create a level db store:</span><br/><span class="hl-1">// const levelDb = new Level&lt;string, any&gt;(&#39;./db&#39;);</span><br/><span class="hl-1">// const store = new LevelStore(levelDb, Field, &#39;test&#39;);</span><br/><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">smt</span><span class="hl-0"> = </span><span class="hl-2">await</span><span class="hl-0"> </span><span class="hl-3">SparseMerkleTree</span><span class="hl-0">.</span><span class="hl-6">buildNewTree</span><span class="hl-0">&lt;</span><span class="hl-7">Field</span><span class="hl-0">, </span><span class="hl-7">Field</span><span class="hl-0">&gt;(</span><span class="hl-3">store</span><span class="hl-0">);</span><br/><span class="hl-1">// or import a tree by store</span><br/><span class="hl-1">// smt = await SparseMerkleTree.importTree(store);</span><br/><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">testKey</span><span class="hl-0"> = </span><span class="hl-6">Field</span><span class="hl-0">(</span><span class="hl-8">1</span><span class="hl-0">);</span><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">testValue</span><span class="hl-0"> = </span><span class="hl-6">Field</span><span class="hl-0">(</span><span class="hl-8">2</span><span class="hl-0">);</span><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">newValue</span><span class="hl-0"> = </span><span class="hl-6">Field</span><span class="hl-0">(</span><span class="hl-8">3</span><span class="hl-0">);</span><br/><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">root</span><span class="hl-0"> = </span><span class="hl-2">await</span><span class="hl-0"> </span><span class="hl-3">smt</span><span class="hl-0">.</span><span class="hl-6">update</span><span class="hl-0">(</span><span class="hl-3">testKey</span><span class="hl-0">, </span><span class="hl-3">testValue</span><span class="hl-0">);</span><br/><span class="hl-1">// Create a compacted merkle proof for a key against the current root.</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">cproof</span><span class="hl-0"> = </span><span class="hl-2">await</span><span class="hl-0"> </span><span class="hl-3">smt</span><span class="hl-0">.</span><span class="hl-6">proveCompact</span><span class="hl-0">(</span><span class="hl-3">testKey</span><span class="hl-0">);</span><br/><span class="hl-1">// erify the compacted Merkle proof</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">ok</span><span class="hl-0"> = </span><span class="hl-6">verifyCompactProof</span><span class="hl-0">(</span><span class="hl-3">cproof</span><span class="hl-0">, </span><span class="hl-3">root</span><span class="hl-0">, </span><span class="hl-3">testKey</span><span class="hl-0">, </span><span class="hl-3">testValue</span><span class="hl-0">);</span><br/><span class="hl-3">console</span><span class="hl-0">.</span><span class="hl-6">log</span><span class="hl-0">(</span><span class="hl-4">&#39;ok: &#39;</span><span class="hl-0">, </span><span class="hl-3">ok</span><span class="hl-0">);</span><br/><br/><span class="hl-1">// Create a merkle proof for a key against the current root.</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">proof</span><span class="hl-0"> = </span><span class="hl-2">await</span><span class="hl-0"> </span><span class="hl-3">smt</span><span class="hl-0">.</span><span class="hl-6">prove</span><span class="hl-0">(</span><span class="hl-3">testKey</span><span class="hl-0">);</span><br/><br/><span class="hl-1">// Note that only methods whose method name ends with InCircuit can run in zkapp (the smart contract of the mina protocol)</span><br/><span class="hl-1">// Verify the Merkle proof in zkapp</span><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">isOk</span><span class="hl-0"> = </span><span class="hl-6">verifyProofInCircuit</span><span class="hl-0">(</span><span class="hl-3">proof</span><span class="hl-0">, </span><span class="hl-3">root</span><span class="hl-0">, </span><span class="hl-3">testKey</span><span class="hl-0">, </span><span class="hl-3">testValue</span><span class="hl-0">, </span><span class="hl-3">Field</span><span class="hl-0">);</span><br/><span class="hl-5">let</span><span class="hl-0"> </span><span class="hl-3">newRoot</span><span class="hl-0"> = </span><span class="hl-6">computeRootInCircuit</span><span class="hl-0">(</span><span class="hl-3">proof</span><span class="hl-0">.</span><span class="hl-3">sideNodes</span><span class="hl-0">, </span><span class="hl-3">testKey</span><span class="hl-0">, </span><span class="hl-3">newValue</span><span class="hl-0">, </span><span class="hl-3">Field</span><span class="hl-0">);</span><br/><span class="hl-3">console</span><span class="hl-0">.</span><span class="hl-6">log</span><span class="hl-0">(</span><span class="hl-4">&#39;newRoot: &#39;</span><span class="hl-0">, </span><span class="hl-3">newRoot</span><span class="hl-0">.</span><span class="hl-6">toString</span><span class="hl-0">());</span><br/><br/><span class="hl-1">// another way to verify</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">keyHash</span><span class="hl-0"> = </span><span class="hl-3">Poseidon</span><span class="hl-0">.</span><span class="hl-6">hash</span><span class="hl-0">([</span><span class="hl-3">testKey</span><span class="hl-0">]);</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">valueHash</span><span class="hl-0"> = </span><span class="hl-3">Poseidon</span><span class="hl-0">.</span><span class="hl-6">hash</span><span class="hl-0">([</span><span class="hl-3">testValue</span><span class="hl-0">]);</span><br/><span class="hl-5">const</span><span class="hl-0"> </span><span class="hl-9">newValueHash</span><span class="hl-0"> = </span><span class="hl-3">Poseidon</span><span class="hl-0">.</span><span class="hl-6">hash</span><span class="hl-0">([</span><span class="hl-3">newValue</span><span class="hl-0">]);</span><br/><span class="hl-1">// existence merkle proof</span><br/><span class="hl-3">isOk</span><span class="hl-0"> = </span><span class="hl-6">verifyProofByFieldInCircuit</span><span class="hl-0">(</span><span class="hl-3">proof</span><span class="hl-0">, </span><span class="hl-3">root</span><span class="hl-0">, </span><span class="hl-3">keyHash</span><span class="hl-0">, </span><span class="hl-3">valueHash</span><span class="hl-0">);</span><br/><span class="hl-1">// non-existence merkle proof</span><br/><span class="hl-3">isOk</span><span class="hl-0"> = </span><span class="hl-6">verifyProofByFieldInCircuit</span><span class="hl-0">(</span><span class="hl-3">proof</span><span class="hl-0">, </span><span class="hl-3">root</span><span class="hl-0">, </span><span class="hl-3">keyHash</span><span class="hl-0">, </span><span class="hl-9">SMT_EMPTY_VALUE</span><span class="hl-0">);</span><br/><span class="hl-3">newRoot</span><span class="hl-0"> = </span><span class="hl-6">computeRootByFieldInCircuit</span><span class="hl-0">(</span><span class="hl-3">proof</span><span class="hl-0">.</span><span class="hl-3">sideNodes</span><span class="hl-0">, </span><span class="hl-3">keyHash</span><span class="hl-0">, </span><span class="hl-3">newValueHash</span><span class="hl-0">);</span>
</code></pre>

<a href="#api-reference" id="api-reference" style="color: inherit; text-decoration: none;">
  <h1>API Reference</h1>
</a>
<ul>
<li><a href="https://comdex.github.io/snarky-smt/">More API Document</a></li>
</ul>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/CDeepSparseMerkleSubTree.html" class="tsd-kind-icon">CDeep<wbr/>Sparse<wbr/>Merkle<wbr/>Sub<wbr/>Tree</a></li><li class="tsd-kind-class"><a href="classes/CSparseMerkleProof.html" class="tsd-kind-icon">CSparse<wbr/>Merkle<wbr/>Proof</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/CSparseMerkleTree.html" class="tsd-kind-icon">CSparse<wbr/>Merkle<wbr/>Tree</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/LevelStore.html" class="tsd-kind-icon">Level<wbr/>Store</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/MemoryStore.html" class="tsd-kind-icon">Memory<wbr/>Store</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/MultiVersionSparseMerkleTree.html" class="tsd-kind-icon">Multi<wbr/>Version<wbr/>Sparse<wbr/>Merkle<wbr/>Tree</a></li><li class="tsd-kind-class"><a href="classes/SparseMerkleProof.html" class="tsd-kind-icon">Sparse<wbr/>Merkle<wbr/>Proof</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/SparseMerkleTree.html" class="tsd-kind-icon">Sparse<wbr/>Merkle<wbr/>Tree</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/TreeHasher.html" class="tsd-kind-icon">Tree<wbr/>Hasher</a></li><li class="tsd-kind-interface"><a href="interfaces/CSparseCompactMerkleProof.html" class="tsd-kind-icon">CSparse<wbr/>Compact<wbr/>Merkle<wbr/>Proof</a></li><li class="tsd-kind-interface"><a href="interfaces/FieldElements.html" class="tsd-kind-icon">Field<wbr/>Elements</a></li><li class="tsd-kind-interface"><a href="interfaces/SparseCompactMerkleProof.html" class="tsd-kind-icon">Sparse<wbr/>Compact<wbr/>Merkle<wbr/>Proof</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Store.html" class="tsd-kind-icon">Store</a></li><li class="tsd-kind-type-alias"><a href="modules.html#Hasher" class="tsd-kind-icon">Hasher</a></li><li class="tsd-kind-type-alias"><a href="modules.html#SparseCompactMerkleProofJSONValue" class="tsd-kind-icon">Sparse<wbr/>Compact<wbr/>Merkle<wbr/>ProofJSONValue</a></li><li class="tsd-kind-variable"><a href="modules.html#SMT_EMPTY_VALUE" class="tsd-kind-icon">SMT_<wbr/>EMPTY_<wbr/>VALUE</a></li><li class="tsd-kind-function"><a href="modules.html#compactProof" class="tsd-kind-icon">compact<wbr/>Proof</a></li><li class="tsd-kind-function"><a href="modules.html#compactProof_C" class="tsd-kind-icon">compact<wbr/>Proof_<wbr/>C</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#computeRoot" class="tsd-kind-icon">compute<wbr/>Root</a></li><li class="tsd-kind-function"><a href="modules.html#computeRootByFieldInCircuit" class="tsd-kind-icon">compute<wbr/>Root<wbr/>By<wbr/>Field<wbr/>In<wbr/>Circuit</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#computeRootInCircuit" class="tsd-kind-icon">compute<wbr/>Root<wbr/>In<wbr/>Circuit</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createEmptyValue" class="tsd-kind-icon">create<wbr/>Empty<wbr/>Value</a></li><li class="tsd-kind-function"><a href="modules.html#decompactProof" class="tsd-kind-icon">decompact<wbr/>Proof</a></li><li class="tsd-kind-function"><a href="modules.html#decompactProof_C" class="tsd-kind-icon">decompact<wbr/>Proof_<wbr/>C</a></li><li class="tsd-kind-function"><a href="modules.html#fromCompactProofJSONValue" class="tsd-kind-icon">from<wbr/>Compact<wbr/>ProofJSONValue</a></li><li class="tsd-kind-function"><a href="modules.html#printBits" class="tsd-kind-icon">print<wbr/>Bits</a></li><li class="tsd-kind-function"><a href="modules.html#strToFieldArry" class="tsd-kind-icon">str<wbr/>To<wbr/>Field<wbr/>Arry</a></li><li class="tsd-kind-function"><a href="modules.html#toCompactProofJSONValue" class="tsd-kind-icon">to<wbr/>Compact<wbr/>ProofJSONValue</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#verifyCompactProof" class="tsd-kind-icon">verify<wbr/>Compact<wbr/>Proof</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#verifyCompactProof_C" class="tsd-kind-icon">verify<wbr/>Compact<wbr/>Proof_<wbr/>C</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#verifyProof" class="tsd-kind-icon">verify<wbr/>Proof</a></li><li class="tsd-kind-function"><a href="modules.html#verifyProofByFieldInCircuit" class="tsd-kind-icon">verify<wbr/>Proof<wbr/>By<wbr/>Field<wbr/>In<wbr/>Circuit</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#verifyProofInCircuit" class="tsd-kind-icon">verify<wbr/>Proof<wbr/>In<wbr/>Circuit</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#verifyProof_C" class="tsd-kind-icon">verify<wbr/>Proof_<wbr/>C</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li><li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>